# memory.yaml — Home Agent Project Memory
# Living document tracking project history, decisions, and current state.
# LLM agents read this before starting any work to understand context.
# Updated after each completed step by autodev.

project: home-agent
last_updated: "2026-02-27"

current_state:
  phase: 2
  step: "2.6"
  name: "Search Disambiguation"
  status: "complete"
  next_step: "2.7 — Wire & Verify UX Flow"
  description: "Steps 2.5+2.6 complete — Rewrote static system prompt with structured ## Media Requests section containing full SEARCH→DISAMBIGUATE→QUALITY→CONFIRM numbered flow. Disambiguation presents numbered list with title, year, type, one distinguishing detail. Never exposes TMDB IDs or technical identifiers. Single clear match skips to QUALITY. Franchise/sequel handling included. Dynamic prompt refactored to structured ## Current User Context block. 10 new tests covering prompt content, quality/language/confirmation injection, and tool callability."
  working_features:
    - "Config loading from .env via pydantic-settings"
    - "SQLite async database with conversations and user_profiles tables"
    - "Message save/retrieve and profile save/retrieve functions"
    - "Pydantic user profile models (UserProfile, MediaPreferences) — simplified with movie_quality, series_quality, reply_language, confirmation_mode"
    - "ProfileManager with async get/save and automatic default profile creation"
    - "HistoryManager wrapping db.py for conversation history CRUD"
    - "sliding_window_processor for PydanticAI history_processors (last N pairs)"
    - "Telegram bot with whitelist enforcement and typing indicator"
    - "PydanticAI agent with AgentDeps, dynamic system prompt, update_user_note tool"
    - "Dynamic system prompt injects movie_quality, series_quality (or 'NOT SET'), reply_language, confirmation_mode"
    - "bot.py wired to call agent and persist conversation history"
    - "Jellyseerr community MCP server deployed via Docker Compose (deployment/docker-compose.yml)"
    - "MCPRegistry with register(), get_toolsets(), get_tool_names() — creates FastMCPToolset instances for enabled servers"
    - "ServerConfig dataclass and get_jellyseerr_config() factory in mcp/servers.py"
    - "Import-linter contract enforcing mcp layer does not import agent, bot, or main"
    - "main.py composition root: config → logging → DB init → managers → MCP registry → bot polling"
    - "get_agent_toolsets() helper in agent.py for MCP toolset retrieval"
    - "Import-linter Layer 4 contract: no other module imports main"
    - "Multi-stage Dockerfile: uv build stage + python slim runtime stage, non-root appuser"
    - "deployment/docker-compose.yml orchestrates home-agent + jellyseerr-mcp with shared network and persistent volume"
    - "MCP_HOST env var in servers.py for Docker service discovery (defaults to localhost)"
    - "mcp_port config field in AppConfig"
    - ".dockerignore excludes tests, docs, .venv, IDE files, data"
    - "async with agent: lifted to main.py startup — MCP connection stays open for bot lifetime"
    - "Error handler registered in bot.py (_error_handler) — all unhandled exceptions now logged"
    - "Empty agent output guard in bot.py — prevents silent failure when model returns empty string"
    - "patched main.py volume-mounted into jellyseerr-mcp container — disables DNS rebinding protection and binds to 0.0.0.0"
    - "PYTHONPATH=/app/src in Dockerfile runtime stage — required because uv installs as editable"
    - "Compose run command: docker compose -f deployment/docker-compose.yml --env-file .env up -d"
    - "Old profiles with removed fields (NotificationPrefs, stats, old MediaPreferences) migrate seamlessly on next load/save"
    - "Auto-detect reply language from Telegram locale on first profile creation (resolve_language in profile.py)"
    - "ProfileManager.get() accepts language_code kwarg — only used for new user creation, existing profiles unaffected"
    - "AppConfig has jellyseerr_4k_profile_id and jellyseerr_1080p_profile_id (int | None = None) with positive-int validation"
    - "Profile tools package: src/home_agent/tools/ with set_movie_quality, set_series_quality, set_reply_language, set_confirmation_mode"
    - "Profile tools registered on agent via agent_instance.tool(fn) in create_agent()"
    - "Tools use RunContext[Any] to avoid circular import with agent.py (import-linter Layer 2 constraint)"
    - "Import-linter contract merged: 'tools and mcp do not import agent or bot' covers both packages"
    - "Static system prompt with structured ## Media Requests flow: SEARCH→DISAMBIGUATE→QUALITY→CONFIRM"
    - "Disambiguation: numbered list with title, year, type, one distinguishing detail — never exposes TMDB IDs or technical identifiers"
    - "Single clear match skips disambiguation, franchise/sequel handling, user mind-change restarts from search"
    - "Dynamic system prompt refactored to ## Current User Context block with name, reply_language, confirmation_mode, quality preferences, notes"
  known_issues: []

completed_steps:
  - step: "1.1"
    name: "Project Scaffolding"
    date: "2026-02-13"
    summary: "Created project structure with uv, pydantic-settings AppConfig, .env.example"
    decisions:
      - "Used pydantic-settings for config with env vars"
      - "ALLOWED_TELEGRAM_IDS parses as comma-separated list of ints"
    issues: []

  - step: "1.2"
    name: "SQLite Database Layer"
    date: "2026-02-13"
    summary: "Async SQLite layer with aiosqlite. init_db(), save/get for messages and profiles."
    decisions:
      - "Used aiosqlite for async DB access"
      - "Single file SQLite, sufficient for home server use case"
    issues: []

  - step: "1.3"
    name: "User Profile Model"
    date: "2026-02-13"
    summary: "Pydantic models for user profiles (UserProfile, MediaPreferences, NotificationPrefs) and ProfileManager class with async get/save for database persistence via db.py."
    decisions:
      - "Used model_dump(mode='json') for serialization to ensure datetime/time objects are stored as ISO strings"
      - "ProfileManager uses model_copy() for immutable profile updates rather than in-place mutation"
      - "Default profile template pattern allows customization via constructor injection"
      - "user_id stored as DB key, not in the serialized data blob"
    issues: []

  - step: "1.5"
    name: "Telegram Bot Skeleton"
    date: "2026-02-13"
    summary: "bot.py with make_message_handler() closure, whitelist enforcement, ChatAction.TYPING indicator, stub echo reply. create_application() factory and run_bot() entry point. Import linter contract 'bot does not import main' activated."
    decisions:
      - "Used make_message_handler(config) closure pattern so handler captures config without global state"
      - "ChatAction lives in telegram.constants (not telegram) in python-telegram-bot v21+"
      - "create_application() returns Application without starting polling so callers control lifecycle"
    issues: []

  - step: "1.6"
    name: "PydanticAI Agent Setup"
    date: "2026-02-22"
    summary: "agent.py with AgentDeps dataclass, OpenRouter model, dynamic system prompt injecting UserProfile, update_user_note tool. bot.py wired to call agent and persist history."
    decisions:
      - "Used openrouter:qwen/qwq-32b:free as the model"
      - "sliding_window_processor(n=20) used as history_processors to limit token cost"
      - "Dynamic system_prompt injects user profile at call time via @agent.system_prompt(dynamic=True)"
      - "bot.py uses async with agent: for lifecycle management per coding guidelines"
      - "History persisted as raw role/content strings in DB; converted to ModelMessage on load"
    issues: []

  - step: "1.7"
    name: "Jellyseerr MCP Server"
    date: "2026-02-22"
    summary: "Community MCP server (ghcr.io/aserper/jellyseerr-mcp) deployed via Docker Compose in deployment/docker-compose.yml. Exposes HTTP MCP endpoint at http://localhost:5056/mcp. No custom code written — connected to agent via FastMCPToolset('http://localhost:5056/mcp') in step 1.8."
    decisions:
      - "Used community Docker image (ghcr.io/aserper/jellyseerr-mcp) instead of building a custom FastMCP server — per AGENTS.md 'prefer existing over custom' guideline"
      - "MCP server runs as a sidecar Docker container, decoupled from the Python app"
      - "Agent connects via HTTP: FastMCPToolset('http://localhost:5056/mcp') — no subprocess, no custom code"
      - "Config (JELLYSEERR_URL, JELLYSEERR_API_KEY, MCP_PORT) passed as Docker environment variables from .env"
    issues: []

  - step: "1.8"
    name: "MCP Registry & Lifecycle"
    date: "2026-02-24"
    summary: "Created src/home_agent/mcp/ package with MCPRegistry, ServerConfig dataclass, and get_jellyseerr_config() factory. Registry creates FastMCPToolset instances for enabled HTTP MCP servers. Import-linter contract active. 8 new unit tests."
    decisions:
      - "MCPRegistry holds ServerConfig instances and creates FastMCPToolset(url) on demand — no start/stop needed since Docker manages server lifecycle"
      - "ServerConfig is a plain dataclass (not Pydantic BaseModel) — no validation needed, pure config container"
      - "Separate mcp-only import-linter contract added now; will be merged with home_agent.tools contract when tools package is created (step 1.9+)"
      - "FastMCPToolset is lazy — safe to instantiate without a live connection"
    issues: []

  - step: "1.4"
    name: "Conversation History & Processor"
    date: "2026-02-13"
    summary: "HistoryManager wrapping db.py for conversation history CRUD; sliding_window_processor closure for PydanticAI history_processors keeping last N request/response pairs."
    decisions:
      - "HistoryManager delegates entirely to db.save_message/get_history — no duplication"
      - "sliding_window_processor is a closure returning a processor function for configurability"
      - "Unpaired trailing ModelRequest at window boundary is excluded to avoid splitting pairs"
      - "TextPart uses 'content' kwarg (not 'text') in installed pydantic-ai version"
    deferred:
      - id: "DEFER-1.4-001"
        title: "User profile injection into history context"
        original_task: "Step 1.4 Task 4 — Integrate user profile into system prompt context"
        reason: >
          Per architecture guidelines (AGENTS.md), profile injection belongs in agent.py
          via a dynamic @agent.system_prompt, not in history.py. Placing it in history.py
          would couple the history layer to the profile layer, violating the separation of
          concerns defined in the architecture. This is deferred to Step 1.6 (Agent definition)
          where agent.py will use @agent.system_prompt(dynamic=True) to inject UserProfile data.
        target_step: "1.6"
        status: "resolved"
        resolved_in: "1.6"
        resolution: "inject_user_profile() dynamic system prompt in agent.py injects UserProfile data per AGENTS.md architecture."
    issues: []

  - step: "1.9"
    name: "Wire It Together"
    date: "2026-02-24"
    summary: "Created main.py composition root, added get_agent_toolsets() helper to agent.py, wrote integration tests and main tests, added import-linter contract forbidding imports of main, updated .env.example with MCP_PORT."
    decisions:
      - "main.py is the composition root — only place where all components assemble"
      - "setup_logging() calls both basicConfig and getLogger().setLevel() to handle the case where basicConfig is a no-op (already-configured handlers in test environment)"
      - "get_agent_toolsets() added to agent.py (not main.py) to keep MCP toolset logic close to the agent — agent.py is allowed to import from mcp per import-linter contracts"
      - "Integration tests mock home_agent.bot.agent (import location) not home_agent.agent.agent (definition location)"
      - "MCPRegistry created in main.py but toolsets not yet passed to agent — agent uses async with agent: for lifecycle, toolsets are a future wiring concern"
    issues: []

  - step: "2.1"
    name: "Simplify UserProfile"
    date: "2026-02-26"
    summary: "Simplified UserProfile and MediaPreferences models. Removed dead fields (NotificationPrefs, stats, preferred_genres, avoid_genres, preferred_language). Added movie_quality/series_quality (Literal['4k', '1080p'] | None), reply_language (str, default 'english'), confirmation_mode (Literal['always', 'never'], default 'always'). Updated dynamic system prompt in agent.py to inject new fields. Migration handled by Pydantic v2 ignoring unknown fields on deserialization."
    decisions:
      - "No explicit ConfigDict(extra='ignore') needed — Pydantic v2 ignores extra fields by default"
      - "agent.py dynamic prompt updated in this step (not deferred to 2.5) because old field references would have broken"
      - "confirmation_mode uses only 'always' and 'never' — 'smart' rejected per plan sparring as YAGNI"
    issues: []

  - step: "2.2"
    name: "Auto-detect Reply Language"
    date: "2026-02-27"
    summary: "New users get reply_language auto-detected from Telegram locale on first profile creation. Added resolve_language() function with minimal locale-to-language mapping (nl→Dutch, en→English, fr→French, de→German, es→Spanish, fallback→English). ProfileManager.get() accepts optional language_code kwarg, used only for new users. bot.py reads update.effective_user.language_code and passes it through. UserProfile.reply_language default capitalized from 'english' to 'English' for consistency with resolve output."
    decisions:
      - "Mapping kept minimal — only languages the admin expects users to speak, extend as needed"
      - "es→Spanish added beyond plan spec (nl, en, fr, de) — acceptable minimal extension"
      - "language_code is keyword-only arg on ProfileManager.get() to avoid breaking existing callers"
      - "Existing profiles are never modified when language_code is passed — only affects new user creation"
      - "UserProfile.reply_language default changed from 'english' to 'English' for consistency with resolve_language() output"
    issues: []

  - step: "2.3"
    name: "Admin Config for Quality Profiles"
    date: "2026-02-27"
    summary: "Added jellyseerr_4k_profile_id and jellyseerr_1080p_profile_id (int | None = None) to AppConfig with field_validator rejecting zero and negative values. .env.example updated with commented-out examples and instructions for finding IDs in Jellyseerr settings."
    decisions:
      - "Both fields default to None — bot works out of the box without requiring admin to look up profile IDs"
      - "Zero is rejected alongside negative values — Jellyseerr profile IDs are always positive integers"
      - "Validator covers both fields with a single @field_validator decorator"
    issues: []

  - step: "2.4"
    name: "Profile Tools"
    date: "2026-02-27"
    summary: "Created src/home_agent/tools/ package with 4 profile tools: set_movie_quality, set_series_quality, set_reply_language, set_confirmation_mode. All async, return confirmation strings, persist via ProfileManager. Registered on agent in create_agent() via agent_instance.tool(fn). 9 new tests (8 unit with DB roundtrip + 1 integration verifying tool registration)."
    decisions:
      - "Tools use RunContext[Any] instead of RunContext[AgentDeps] — import-linter catches even TYPE_CHECKING-guarded imports, so importing AgentDeps from agent.py would break the Layer 2 contract"
      - "Tools defined as standalone async functions in tools/profile_tools.py, registered in agent.py via agent_instance.tool(fn) — avoids circular import while keeping registration explicit"
      - "Import-linter contract merged: replaced separate 'mcp does not import agent or bot' with combined 'tools and mcp do not import agent or bot'"
      - "set_movie_quality and set_series_quality mutate nested media_preferences in place; set_reply_language and set_confirmation_mode use model_copy on the top-level profile — both patterns are valid, asymmetry is acceptable"
    issues: []

  - step: "2.5"
    name: "System Prompt & Confirmation Flow"
    date: "2026-02-27"
    summary: "Rewrote static system prompt with structured Markdown sections (## Media Requests, ## Language, ## Preferences). Added full numbered SEARCH→DISAMBIGUATE→QUALITY→CONFIRM flow. Dynamic prompt refactored from single-line to structured ## Current User Context block with newline-joined parts. Quality onboarding asks '4K or 1080p?' when preference is NOT SET. Confirmation policy respects confirmation_mode. Language section instructs reply in profile.reply_language."
    decisions:
      - "Static and dynamic prompts use Markdown ## headers for clarity — LLMs parse structured prompts better"
      - "Quality onboarding text changed from 'NOT SET — ask before first request' to 'NOT SET — ask the user before making any movie/series request' for explicitness"
      - "Dynamic prompt uses list-join pattern instead of f-string concatenation for readability"
    issues: []

  - step: "2.6"
    name: "Search Disambiguation"
    date: "2026-02-27"
    summary: "Disambiguation instructions integrated into the static system prompt's DISAMBIGUATE step. Multiple results presented as numbered list with title, year, type, one distinguishing detail. Never expose TMDB IDs or technical identifiers. Single clear match skips to QUALITY. Franchise/sequel handling requires disambiguation unless user was specific. User mind-change restarts from search. Implemented in same commit as step 2.5."
    decisions:
      - "Disambiguation is purely a system prompt instruction — no new code logic needed since the LLM handles the conversational flow"
      - "Behavioral test for 'agent with multiple search results' was intentionally omitted — it would be tautological (testing TestModel's canned output, not agent logic)"
      - "Concrete example (Troy 2004 vs Troy: Fall of a City 2018) included in prompt to anchor LLM behavior"
    issues: []

  - step: "1.10"
    name: "Docker Deployment"
    date: "2026-02-24"
    summary: "Multi-stage Dockerfile (uv build + python:3.12-slim runtime), deployment/docker-compose.yml orchestrating home-agent and jellyseerr-mcp with shared network and persistent volume. Non-root appuser, health checks, MCP_HOST env var for Docker service discovery, mcp_port in AppConfig. 7 smoke tests for Docker config validation. README.md with deployment docs."
    decisions:
      - "Dockerfile uses uv image for build stage but plain python:3.12-slim-bookworm for runtime — avoids shipping uv in production image"
      - "docker-compose.yml lives in deployment/ directory (not project root) to keep root clean and consistent with existing Jellyseerr MCP setup"
      - "MCP_HOST read from os.environ in servers.py (not AppConfig) — it's a Docker-specific override set via docker-compose environment, not a user-facing config"
      - "Entry point uses python -m home_agent.main (not a root main.py stub) for proper package execution"
      - "Health check uses pgrep process detection — sufficient for a long-polling Telegram bot with no HTTP endpoint"
      - "pyyaml added to dev dependencies for docker-compose YAML parsing in smoke tests"
      - ".env.example uses placeholder values only — no real credentials committed to version control"
    issues: []

architecture_decisions:
  - id: "AD-001"
    title: "PydanticAI over LangGraph/Haystack"
    date: "2026-02-13"
    decision: "Use PydanticAI as the agent framework"
    rationale: >
      Model-agnostic, native MCP support, history_processors for token cost control,
      dependency injection, Pythonic. LangGraph's interrupt()/graph machinery is overkill —
      Telegram's message flow is the human-in-the-loop. Haystack's pipeline model is
      optimized for RAG, not conversational agents.
    status: final

  - id: "AD-002"
    title: "MCP for Service Integration (Prefer Existing)"
    date: "2026-02-13"
    decision: "Use MCP to connect to home server services. Search for existing community MCP servers first."
    rationale: "Standard protocol, decoupled, reusable. Avoids hand-writing tool wrappers."
    status: final

  - id: "AD-003"
    title: "OpenRouter Free Tier Only"
    date: "2026-02-13"
    decision: "All LLM calls use free-tier models via OpenRouter. $10 top-up for 1000 free requests/day."
    rationale: "Cost constraint. Free models are capable enough. Token management via sliding window + user profile."
    status: final

  - id: "AD-004"
    title: "Evolving User Profile for Personalization"
    date: "2026-02-13"
    decision: "Agent maintains a per-user profile that evolves over time, injected into system prompt."
    rationale: "Token-efficient personalization. Sliding window loses old context but profile persists key observations."
    status: final

  - id: "AD-005"
    title: "Telegram Conversation as Human-in-the-Loop"
    date: "2026-02-13"
    decision: "No programmatic interrupt mechanism. Agent decides when to ask for confirmation via system prompt."
    rationale: "Natural conversational flow. Simpler than LangGraph's interrupt/resume."
    status: final

  - id: "AD-006"
    title: "SQLite for Persistence"
    date: "2026-02-13"
    decision: "SQLite for conversation history and user profiles."
    rationale: "Zero-dependency, single file on disk, sufficient for single/few users on a home server."
    status: final

home_server_services:
  - name: Jellyseerr
    purpose: "Media requests & discovery"
    mcp_status: community_docker
    mcp_image: "ghcr.io/aserper/jellyseerr-mcp:latest"
    mcp_endpoint: "http://jellyseerr-mcp:5056/sse"
    phase: 1
  - name: Glances
    purpose: "System monitoring"
    mcp_status: not_researched
    phase: 2
  - name: Immich
    purpose: "Photo management"
    mcp_status: not_researched
    phase: 3
  - name: Mealie
    purpose: "Recipe management"
    mcp_status: not_researched
    phase: 3
  - name: BabyBuddy
    purpose: "Baby tracking"
    mcp_status: not_researched
    phase: 3
  - name: Paperless-ngx
    purpose: "Document management"
    mcp_status: not_researched
    phase: 3
  - name: Vikunja
    purpose: "Task management"
    mcp_status: not_researched
    phase: 3
  - name: Portainer
    purpose: "Docker management"
    mcp_status: not_researched
    phase: 3
  - name: Duplicati
    purpose: "Backup management"
    mcp_status: not_researched
    phase: 3
  - name: Uptime Kuma
    purpose: "Uptime monitoring"
    mcp_status: not_researched
    phase: 3
  - name: IT Tools
    purpose: "Utility tools"
    mcp_status: not_researched
    phase: 4
  - name: BentoPDF/Vert
    purpose: "File conversion"
    mcp_status: not_researched
    phase: 4

lessons_learned:
  - id: "LL-001"
    title: "uv installs local package as editable — PYTHONPATH needed in Docker runtime stage"
    date: "2026-02-25"
    context: "Building Docker image for home-agent with uv and src/ layout"
    problem: "uv sync --frozen --no-dev installs the local package as an editable install (a .pth file pointing to /app/src). The runtime stage copies the .venv but the editable .pth link still points to the build stage's path. Result: ModuleNotFoundError: No module named 'home_agent' at startup."
    resolution: "Added ENV PYTHONPATH=/app/src to the runtime stage in Dockerfile. The src/ directory is already copied in the runtime stage so Python finds the package directly. Tried --no-editable flag but it had no effect on this uv version."
    takeaway: "Always set PYTHONPATH=/app/src in the runtime stage when using uv with src/ layout in Docker. Do not rely on --no-editable."

  - id: "LL-002"
    title: "ghcr.io/aserper/jellyseerr-mcp always binds to 127.0.0.1 — needs patched main.py"
    date: "2026-02-25"
    context: "Connecting home-agent Docker container to jellyseerr-mcp Docker container over shared network"
    problem: "The jellyseerr-mcp image always starts Uvicorn on 127.0.0.1 (loopback only). FASTMCP_HOST env var is set in the image but the mcp.server.fastmcp.Settings model ignores it at construction time. Host header validation (MCP's TransportSecuritySettings DNS rebinding protection) also rejects Docker service-name Host headers like 'Host: jellyseerr-mcp'."
    resolution: |
      Volume-mounted a patched main.py into the container at /app/main.py:
      1. Sets host = os.environ.get('MCP_HOST', '0.0.0.0') before calling mcp.run()
      2. Disables DNS rebinding protection: mcp.settings.transport_security = TransportSecuritySettings(enable_dns_rebinding_protection=False)
      3. Runs uvicorn directly with host='0.0.0.0'
      The patched file lives at mcp_servers/jellyseerr/main.py and is mounted via docker-compose volumes.
    takeaway: "When using community MCP Docker images, always verify the bind address. Many images bind to 127.0.0.1 by default, making inter-container communication impossible. A volume-mounted patched entrypoint is cleaner than forking the image."

  - id: "LL-003"
    title: "jellyseerr-mcp uses SSE transport (/sse), not streamable HTTP (/mcp)"
    date: "2026-02-25"
    context: "Connecting FastMCPToolset to jellyseerr-mcp"
    problem: "FastMCPToolset defaults to streamable HTTP and connects to /mcp. The jellyseerr-mcp server only exposes /sse (GET for SSE stream) and /messages (POST). Connecting to /mcp returned 421 Misdirected Request or connection refused."
    resolution: "Changed ServerConfig URL from http://jellyseerr-mcp:5056/mcp to http://jellyseerr-mcp:5056/sse. FastMCPToolset automatically detects SSE transport from the /sse path."
    takeaway: "When connecting to MCP servers, always verify which transport they support. Older mcp.server.fastmcp servers use SSE (/sse + /messages). Newer fastmcp servers use streamable HTTP (/mcp). Check via curl first."

  - id: "LL-004"
    title: "Docker Compose .env auto-load only works from compose file directory"
    date: "2026-02-25"
    context: "Running docker compose -f deployment/docker-compose.yml from project root"
    problem: "WARN: JELLYSEERR_API_KEY variable is not set. Docker Compose auto-loads .env only from the directory of the compose file (deployment/), not the current working directory or project root."
    resolution: "Always run with explicit --env-file flag: docker compose -f deployment/docker-compose.yml --env-file .env up -d. Documented in deployment/README.md and as a comment in docker-compose.yml."
    takeaway: "When compose file is not at project root, always pass --env-file .env explicitly. Document this in README."

  - id: "LL-005"
    title: "Docker healthcheck without curl — use Python socket check"
    date: "2026-02-25"
    context: "Healthcheck for jellyseerr-mcp container which doesn't have curl installed"
    problem: "Healthcheck used CMD curl -f http://localhost:5056/health which fails silently because (a) curl is not installed in the Python-based image and (b) /health endpoint doesn't exist."
    resolution: "Switched healthcheck to: python3 -c \"import socket; s=socket.socket(); s.settimeout(2); s.connect(('127.0.0.1', int(__import__('os').environ.get('PORT','5056')))); s.close()\""
    takeaway: "For Python-based MCP server images, use a Python socket connect healthcheck instead of curl. Verify endpoints exist before using them in healthchecks."

  - id: "LL-006"
    title: "async with agent: must be at app startup, not per-message"
    date: "2026-02-25"
    context: "MCP connection lifecycle in bot.py"
    problem: "Original code called async with agent: inside each message handler, reopening the MCP connection on every message. This is slow and causes session termination errors when the SSE session is reused."
    resolution: "Moved async with agent: to main.py _async_main(). Agent context manager stays open for the entire bot lifetime. bot.py calls agent.run() directly without the context manager."
    takeaway: "async with agent: opens MCP connections. Call it once at startup, keep it open for the bot's lifetime. Never call it per-message."

  - id: "LL-007"
    title: "Register Telegram error handler or exceptions are silently swallowed"
    date: "2026-02-25"
    context: "Debugging silent failures in bot.py message handler"
    problem: "python-telegram-bot logs 'No error handlers are registered' and swallows exceptions from message handlers. Agent errors, MCP failures, and Telegram API errors all disappear silently."
    resolution: "Added app.add_error_handler(_error_handler) in create_application(). Also added try/except around agent.run() with explicit error logging and user-facing error message. Added guard for empty reply (if not reply:) since some free LLM models return empty strings after tool use."
    takeaway: "Always register an error handler with python-telegram-bot. Always wrap agent.run() in try/except. Always guard against empty output from the model."
